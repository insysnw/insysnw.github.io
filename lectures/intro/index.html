<!DOCTYPE html>
<html lang="ru">
  <head>
    <link rel="stylesheet" href="/fonts/stylesheet.css" />
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>Курс ТКС</title>
    <link
      rel="stylesheet"
      href="/insysnw.css"
    />
	<!--
	  Pins footer to the bottom
	  TODO: place it properly
	-->
    <style>
      .course {
        flex: 1;
        display: flex;
        flex-direction: column;
      }

      body {
        display: flex;
        min-height: 100vh;
        flex-direction: column;
      }

      footer {
        margin-top: auto;
      }
    </style>
  </head>

  <body>
    <div class="course">
      <header>
        <nav class="level nerd">
          <p class="level-item has-text-centered">
		    <a href="/lectures">
              <span class="icon">
                <i class="mdi mdi-24px mdi-book-open-page-variant" aria-hidden="true"></i>
              </span>
              <span class="f3270">Лекции</span>
            </a>
          </p>
          <p class="level-item has-text-centered">
		    <a href="/practice">
              <span class="icon">
                <i class="mdi mdi-24px mdi-flask" aria-hidden="true"></i>
              </span>
              <span class="f3270">Практика</span>
            </a>
          </p>
          <p class="level-item has-text-centered">
            <img
              src="https://icst.spbstu.ru/userfiles/files/Risunok-KSPT.png"
              alt="КСПТ"
              style="height: 50px"
            />
          </p>
          <p class="level-item has-text-centered">
		    <a href="/awesome">
              <span class="icon">
                <i class="mdi mdi-24px mdi-sunglasses" style="color: #fc60a8;" aria-hidden="true"></i>
              </span>
              <span class="f3270">Awesome</span>
            </a>
          </p>
          <p class="level-item has-text-centered">
		    <a href="/">
              <span class="icon">
                <i class="mdi mdi-24px mdi-information-outline" aria-hidden="true"></i>
              </span>
              <span class="f3270">О курсе</span>
            </a>
          </p>
        </nav>
      </header>
      <main>
        <section class="section">
          <div class="container">

<h1 class="title">
Введение. TCP&#x2F;IP.
<h1>

<div class="content">
<h1 id="zachem-nuzhny-komp-iuternye-seti">Зачем нужны компьютерные сети?</h1>
<p>Прежде чем погружаться в изучение компьютерных сетей, давайте сначала разберёмся, где компьютерные сети применяются.
Есть очевидные случаи, когда вы пользуетесь ими почти на прямую:</p>
<ul>
<li>Стриминговые сервисы, передающие на ваше устройство медиа контент (Netflix, Spotify, Яндекс музыка, Youtube, Twitch)</li>
<li>Социальные сети и месенджеры (VK, Telegram, email, Element)</li>
<li>Вэб порталы и магазины (Сайт гос услуг, Aliexpress)</li>
<li>Он-лайн игры</li>
<li>Обновления ОС или программ</li>
</ul>
<p>Но есть и чуточку более абстрагированные случаи:</p>
<ul>
<li>Системы платежей (Visa, MasterCard, МИР)</li>
<li>Удалённое управление (рабочие места, домофоны, квадрокоптеры)</li>
<li>Промышленность (системы управления заводом, складом)</li>
</ul>
<h2 id="ozhidaniia">Ожидания</h2>
<p>Давайте ненадолго забудем, что мы тут обсуждаем сети и соберём наши ожидания от всех вышеперечисленных сервисов.</p>
<p>Оплачивая покупку банковской картой мы бы хотели действительно оплатить покупки, а не наслаждаться вечно крутящимся кружком загрузки.
То есть нам хочется иметь <strong>доступный</strong> сервис.</p>
<p>Помимо самого факта оплаты, мы бы очень хотели, чтобы оплата прошла ровно один раз и по указанной сумме.
Это свойство можно охарактеризовать как <strong>надёжность</strong>.</p>
<p>Думаю, многие предпочли бы использовать наличный расчет, если бы каждая оплата банковской картой занимала по 10 минут, поэтому мы ожидаем от такого сервиса <strong>отзывчивости</strong>.</p>
<p>Следующее ожидание на примере использования системы оплаты в качестве потребителя сложно прочувствовать.
Намного проще на него посмотреть со стороны банка.
У вас, как у потребителя услуг в банка одновременные взаимоотношения с единицами банков, а клиентов у банка могут быть миллионы.
Очень большое количество клиентов может провести какую-нибудь операцию примерно в одно время.
Чтобы сохранить репутацию надёжного банка, его сервисы должны быть достаточно <strong>производительны</strong>, чтобы обслужить всех.</p>
<p>Последнее, но самое важное из ожиданий - <strong>совместимость</strong>.
Почти наверняка ваша банковская карта работает более чем в одном магазине и банкомате.
Её принимают он-лайн площадки.
И всё её же можно подключить во многие телефоны и даже некоторые умные часы.</p>
<p>Всё это произошло не случайно.
Залогом успеха взаимодействия сложных систем является чёткое описание взаимодействий.
Одна из форм такого описания - протокол.</p>
<h1 id="protokoly">Протоколы</h1>
<p>Их критически важно отличать от реализации и интерфейса.</p>
<p><strong>Протокол</strong>:
В нашем случае под протоколом мы подразумеваем набор действий и правил, например, последовательности этих действий.
Чаще всего это текстовое, а иногда и графическое описание.
Известным примером протокола является HTTP, а тестовое описание его версии 1.0 можно найти в <a href="https://tools.ietf.org/html/rfc1945">RFC 1945</a>.</p>
<p>Пример псевдографической составляющей мы берём из <a href="https://tools.ietf.org/html/rfc791#page-11">RFC 791</a>, оисывающего Internet Protocol:</p>
<pre style="background-color:#2b303b;color:#c0c5ce;"><code><span>  0                   1                   2                   3
</span><span>    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
</span><span>   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
</span><span>   |Version|  IHL  |Type of Service|          Total Length         |
</span><span>   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
</span><span>   |         Identification        |Flags|      Fragment Offset    |
</span><span>   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
</span><span>   |  Time to Live |    Protocol   |         Header Checksum       |
</span><span>   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
</span><span>   |                       Source Address                          |
</span><span>   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
</span><span>   |                    Destination Address                        |
</span><span>   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
</span><span>   |                    Options                    |    Padding    |
</span><span>   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
</span><span>
</span><span>                    Example Internet Datagram Header
</span></code></pre>
<p><strong>Реализация</strong>:
На примере всё того же HTTP, его реализуют почти все браузеры.
Если покопаться в исходных кодах FireFox или Chromium, то можно найти части, ответственные за обработку HTTP.
Они будут отличаться.
И именно эти части и являются реализацией.
Другой интересный пример реализации HTTP - <a href="https://curl.se">curl</a></p>
<p><strong>Интерфейс</strong>:
Обсуждая реализацию мы упомянули разные браузеры.
Адресные строки в них выглядят чутка по разному, но не это отличие нас интересует в этом контексте.
Нам важно знать, как отличается интерфейс от реализации.</p>
<p>Вот пример адресной строки из FireFox:</p>
<p><img src="address_bar.png" alt="Изображение адресной строки браузера" /></p>
<p>В ней протокол <code>https</code> и сам адрес стоят вместе, отсутствуют тип запроса и порт подключения.
И это удобный нам, пользователям браузера, формат.
Однако сам HTTP выглядит иначе, рассмотрим первые две строчки HTTP запроса:</p>
<pre style="background-color:#2b303b;color:#c0c5ce;"><code><span>GET / HTTP/2
</span><span>Host: insysnw.github.io
</span></code></pre>
<p>Это помогает нам понять</p>
<ul>
<li>написанный по спецификации протокола код может сильно различаться, но корректно работать, ведь в нём описана одна логика. <strong>TODO</strong>: перефразировать.</li>
<li>То, что видит пользователь не обязано напрямую соответствовать протоколу и наоборот</li>
<li>Код не является спецификацией протокола <strong>TODO</strong>: подвести к этому</li>
</ul>
<h1 id="osnova-sovremennogo-interneta">Основа современного интернета</h1>
<p>Так как реализовать единый протокол для одновременного решения всех текущих и будущих задач казалось невозможно.
Сетевые протоколы были разбиты на вложенные уровни (стек).</p>
<p>Первой заметной инициативой по созданию такого разбиения была <a href="https://en.wikipedia.org/wiki/OSI_model">модель OSI (Open Systems Interconnection)</a>.</p>
<p>Ниже приведены все 7 уровней этой модели:</p>
<table><thead><tr><th>Прикладной</th><th>Application</th></tr></thead><tbody>
<tr><td>Представления</td><td>Presentation</td></tr>
<tr><td>Сеансовый</td><td>Session</td></tr>
<tr><td>Транспортный</td><td>Transport</td></tr>
<tr><td>Сетевой</td><td>Network</td></tr>
<tr><td>Канальный</td><td>Data link</td></tr>
<tr><td>Физический</td><td>Physical</td></tr>
</tbody></table>
<p>Как работает такое разбиение?
<strong>Инкапсуляция</strong>!
То есть вложение вышестоящего уровня в нижестоящий (путём добавления спереди заголовка нижестоящего уровня и изредка окончания).</p>
<p>Как это помогает?
Это изолирует спектр проблем в конкретный уровень.
Что в свою очередь позволяет разработчику сосредоточить усилия на бизнес логике.
Так разрабатывая свой web-сервер не приходится думать о том, пользуется ли клиент WiFi или подключен к сети оптоволокном.</p>
<p>К слову, мы только что задели второй важный аспект разбиения на уровни.
Протоколы в рамках одного уровня можно заменять.
Не всегда это так просто как с WiFi и оптоволокном и влечёт изменения в других уровнях.
Но даже при этом изменения не затрагивают весь стек.</p>
<p>Хотя все уровни в модели OSI выглядели логичными, в далёкие времена её создания, бизнесу востребованными казались не все.
И до окончания длительной разработки OSI, на сцену выходит актуальный и по сей день стек <strong>TCP/IP</strong>.</p>
<p>В нём были отброшены два уровня: представления и сеансовый.
Тем не менее, их отсутствие в стеке не значит отсутствие проблем.
Это привело к миграции решения этих проблем в другие уровни.
Так сеансовый уровень можно встретить в транспортном (протокол TCP, PPTP) и в прикладном (протокол HTTP).
А уровень представления ярко выражен в прикладном: шифрование - TLS, отображение - Unicode, <a href="https://en.wikipedia.org/wiki/HTTP_compression">сжатие в теле HTTP пакета</a>.</p>
<p>Ниже приведены уровни модели TCP/IP <em>(зачёркнутые приведены для демонстрации разницы с OSI)</em></p>
<table><thead><tr><th>Прикладной</th><th>Application</th></tr></thead><tbody>
<tr><td><del>Представления</del></td><td><del>Presentation</del></td></tr>
<tr><td><del>Сеансовый</del></td><td><del>Session</del></td></tr>
<tr><td>Транспортный</td><td>Transport</td></tr>
<tr><td>Сетевой</td><td>Network</td></tr>
<tr><td>Канальный</td><td>Data link</td></tr>
<tr><td>Физический</td><td>Physical</td></tr>
</tbody></table>
<p>В рамках этого курса мы обсудим все уровни кроме физического и канального.</p>
<h1 id="sokety">Сокеты</h1>
<p>Обсудив исключительно теоретическую часть, начнём приближаться к практике!
А на практике для организации сетевого сообщения Операционные Системы(OC) предоставляют программистам особый инструмент - сокеты (англ. socket)</p>
<p><strong>TODO:</strong> изображение глазного яблока / розетки / CPU socket / Ethernet socket</p>
<p>На картинках мы увидели разные типы разъёмов, все они в английском языке обозначаются словом socket.
Те сокеты, что предоставляет нам OC, это абстракция, предоставляющая виртуальный разъём, в который можно подключить какое-то соединение.</p>
<p>Сокеты зародились в мире UNIX подобных систем, где ярко выражена философия “всё файл”.
Так и сокет в этих системах - файл.
Его можно создать специальным системным вызовом, а потом писать и читать так, как вы делаете это с обычным файлом!
Однако гораздо удобнее и эффективнее использовать для чтения и записи системные вызовы предназначенные специально для работы с сокетами.
Скоро мы и до них доберёмся.</p>
<p>Мы обсудили, что в сокеты можно подключать какие-то соединения.
Какие?</p>
<p>Устанавливая розетку у себя дома, мы сначала выбираем её тип (шотке (<strong>TODO</strong>: дать ссылку и привести другие примеры)).
Так и для сокета необходимо выбрать тип (семейство), указывается при создании сокета.
Список семейств, поддерживаемых	Linux можно увидеть в <a href="https://man7.org/linux/man-pages/man7/address_families.7.html">man 7 address_families</a>, но посмотришь лишь на некоторые из них.</p>
<p><strong>UNIX</strong> сокеты являются популярным средством <a href="https://ru.wikipedia.org/wiki/%D0%9C%D0%B5%D0%B6%D0%BF%D1%80%D0%BE%D1%86%D0%B5%D1%81%D1%81%D0%BD%D0%BE%D0%B5_%D0%B2%D0%B7%D0%B0%D0%B8%D0%BC%D0%BE%D0%B4%D0%B5%D0%B9%D1%81%D1%82%D0%B2%D0%B8%D0%B5">IPC</a> и активно упоминаются на курсах Операционных Систем.
Это отличным пример исключительно локального сокета, т.е. сетевые соединения с его помощью не возможны, поэтому оставим его рассмотрение.</p>
<p><strong>Bluetooth</strong> - знакомая многим из вас беспроводная технология.</p>
<p><strong>IR</strong> - инфракрасный порт, сейчас чаще всего встречается в пультах дистанционного управления.
Для него есть сокет, ведь вы можете захотеть управлять кондиционером со своего Android телефона!</p>
<p>Вот мы добрались до двух главных в этом курсе семейств: <strong>IPv4</strong> и <strong>IPv6</strong>.
Именно они являются основным языком всемирной паутины.</p>
<p>Знакомство <strong>IPv6</strong> в этом курсе ещё не подготовлено, так что погрузимся в мир <strong>IPv4</strong>.
Хоть эти два семейства отличаются достаточно сильно, чтобы иметь разные типы сокетов, вполне возможно писать код, который работает сразу с обоими.</p>
<h1 id="ipv4">IPv4</h1>
<p>Начнём разбор с IP пакетов, то есть сетевого уровня.
Это первый уровень на котором возникает возможность адресовать возможность адресовать сетевой узел за рамками прямой видимости.
Но с этим и возникает первая проблема!</p>
<p><strong>Как адресовать другой узел?</strong></p>
<p>Для этого было решено выделить 32 бита, а для удобства разбить их на 4 октета.
Для представлению человеку был выбран формат отображения каждого октета в десятичной системе и разделения их точками.
Например:</p>
<p><code>192.168.1.1</code></p>
<p>Для компьютера такое представление является строкой, что требует больше памяти, проверок и вычислительных ресурсов, чем, например, <code>uint32</code>, вмещающий ровно 32 бита.</p>
<p>Вы, наверное, уже заметили и готовы упрекнуть меня.
“Адрес обычно выглядит иначе!”</p>
<p><code>192.168.1.1/24</code> или <code>192.168.1.1</code> и его маска <code>255.255.255.0</code>.</p>
<p>И тут вы правы!
Свой адрес мы часто обозначаем именно таким образом.
К слову, две вышестоящих записи равносильны.
Обе имеют адрес и маску подсети, просто записаны в разной форме.</p>
<p>Сначала разберёмся, что такое маска, а потом вернёмся к правилам её записи.</p>
<p>А маска это третий по счёту способ определения принадлежности адреса к сети.
До неё сеть определяли по <a href="https://ru.wikipedia.org/wiki/%D0%9A%D0%BB%D0%B0%D1%81%D1%81%D0%BE%D0%B2%D0%B0%D1%8F_%D0%B0%D0%B4%D1%80%D0%B5%D1%81%D0%B0%D1%86%D0%B8%D1%8F">классy</a>(от 1 до 3 первых байт).
А ещё раньше по первым 8 битам.</p>
<p>К счастью об этом теперь можно смело забыть, ведь теперь есть <a href="https://ru.wikipedia.org/wiki/CIDR">CIDR</a>, т.е. те самые маски подсети.</p>
<p>Стоп!
Как забыть?
Раньше сеть хранилась в IP пакете в поле адреса, а теперь появилась маска подсети - отдельное значение.
Где оно хранится?</p>
<p><strong>TODO:</strong> изображение IP пакета</p>
<p>Мы видим, что новое поле для маски подсети не появилось.
Это значит, что в IP пакете маски подсети нет!
А так как нужна она для маршрутизации, там мы её и рассмотрим.</p>
<h2 id="tipy-soketov-ipv4">Типы сокетов IPv4</h2>
<p>Ранее мы договорились, что сокет - абстракция.
Это значит, что абстрагируя IPv4 в сокет можно что-то потерять!
И так оно и произошло, потерялись названия протоколов транспортного уровня.
Создавая сокет, вы не увидите аббревиатуры <code>UDP</code> или <code>TCP</code>.
НО!
Верно отражена суть происходящего.</p>
<p>ОС предоставляет нам три вида сокетов:</p>
<ul>
<li>STREAM</li>
<li>DGRAM (datagram)</li>
<li>RAW</li>
</ul>
<p>Рассмотрим их с точки зрения сложности использования программистом.</p>
<p><strong>Stream</strong> (потоковые) сокеты - самые простые из представленных.
Скрывают за собой протокол транспортного уровня - TCP.
Такие сокеты создают надёжные двунаправленные потоки между двумя узлами.
Это позволяет почти беззаботно писать в сокет и читать из него.
Что такое “надёжные”?
Нет, это не абсолютно устойчивые ко всему соединения, в том числе полному отключению сети или хотя бы её смене (Wifi &lt;-&gt; Мобильное соединени).
Конкретное значение увидим в Datagram сокетах.</p>
<p><strong>Datagram</strong> сокеты оперируют блоками данных и в целом всё.
Название пришло от скрываемого за ними протокола - User <strong>Datagram</strong> Protocol.
В такие сокеты тоже можно просто писать и читать.
И это даже будет работать.
Но ровно до тех пор, пока ваша сеть идеальна, а данные не вылезают за границы размера пакета.
До этого потоковые сокеты позволяли совсем не думать о пакетах, ведь там ядро реализовывало всю логику TCP само, а нам, программистам выдавало уже готовые данные.
Поток ничем искусственно не ограничен и может быть бесконечно длинным.
С блоком данных - будь добр, уложись в ограничения одного пакета!</p>
<p>Велика беда, разбей большой блок на маленькие и передай?
К сожалению, нет.
Пакеты по пути могут потеряться, продублироваться или даже перемешаться.
Обо всём этом теперь нужно думать программисту.
Но пакеты ещё ведь могут и повредиться?
Это - то немногое, что UDP позволяет проверить.
В пакете может быть хэш данных и заголовка, но в версии IPv4 оно не обязательно.</p>
<p><strong>Raw</strong> (сырые) сокеты не скрывают за собой протокол транспортного уровня.
Это позволяет работать напрямую с IP пакетом.
Данный тип мы рассматривать не будет, так как он используется значительно реже остальных.
Обычно это разработка нового протокола транспортного уровня или специфичное взаимодействие с имеющимися.</p>

</div>
</div>
        </section>
      </main>

      <footer class="footer" style="margin-top: auto">
        <div class="content has-text-centered">
          <p>
            Сделяль <a href="https://ejiek.com">@ejiek</a>. Исходный код имеет
            лицензию
            <a href="http://opensource.org/licenses/mit-license.php">MIT</a>.
            Содержимое сайта имеет лицензию
            <a href="https://creativecommons.org/licenses/by/4.0/">CC BY 4.0</a
            >.
          </p>
        </div>
      </footer>
    </div>
  </body>
</html>
